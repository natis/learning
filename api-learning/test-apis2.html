<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>API Learning</title>
	<link rel="stylesheet" href="style2.css">
</head>
<body>
	<!-- button class="loader">Load Data</! -->
	<div class="filters">
		<button class="toggle-geo"><span>Hide</span> Coordinates</button>
	</div><!-- /filters-->
	<table class="city-list sortable">
		<thead>
			<tr>
				<th class="city sortOpt">City</th>
				<th class="state sortOpt">State</th>
				<th class="population sortOpt">Population</th>
				<th class="growth sortOpt">Growth</th>
				<th class="geo">Latitude</th>
				<th class="geo">Longitude</th>
				<th class="rank sortOpt">Rank</th>
			</tr>
		</thead>
		<tbody>			
			
		</tbody>
	</table>
	<script>
		
		/* 
		Here's what data is in the API:
		City Name (city)
		State (state)
		Population (population)
		Growth from 2000 to 2013 in % (growth_from_2000_to_2013)
		(latitude)
		(longitude)
		City's rank in regards to population (rank)
		
		What to do with the data:
		1) Get the data to display in a table ✔️ lines 52 to 95
		1a) Get data to display on page load. ✔️
		2) Let user hide lat and long columns ✔️
		3) Let user sort columns by City Name, State, Rank, and growth
		4) Filter the data based on criteria
		4a) Filter by State - generate dropdown based on available states
		4b) Filter by Growth - dropdown with ranges
		5) Pagination at 50 records a page
		*/
		
		// Variables
		const endpoint = 'https://gist.githubusercontent.com/Miserlou/c5cd8364bf9b2420bb29/raw/2bf258763cdddd704f8ffd3ea9a3e81d25e2c6f6/cities.json';
		const cities = [];
		const theList = document.querySelector('tbody');
		
		// Fetch all the data from the endpoint
		
		const getRepo = async() => {
			return fetch(endpoint)
			.then(blob => blob.json())
			.then(data => cities.push(...data));
		}
		
		//Actually build the table with the data from the json file
		function buildTable() {
			const html = cities.map(place => {
				return `
				<tr>
					<td class="city">${place.city}</td>
					<td class="state">${place.state}</td>
					<td class="population">${numberWithCommas(place.population)}</td>
					<td class="growth">${place.growth_from_2000_to_2013}</td>
					<td class="geo">${place.latitude}</td>
					<td class="geo">${place.longitude}</td>
					<td class="rank">${place.rank}</td>
				</tr>
				`;
			}).join('');
			theList.innerHTML = html;
		}
		
		async function buildPage() {
			await getRepo();
			buildTable();
		}
		
		//Let's put a comma in the population count got this from a previous tutorial. dude said to just bookmark this regex snippet
		function numberWithCommas(x) {
			return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
		}
		
		buildPage();
		
		// Hide/show long/lat columns
		/* 	Lesson here is that if you're getting a bunch of elements that all share a class/data-* or whatever, you can't use
		classList as that targets an individual item, you need a forEach with an arrow function.
		Honestly, this shit is easier in Jquery.
		*/
		const hideGeoloc = document.querySelector('.toggle-geo');
		function toggleLongLat() {
			const geoLoc = document.querySelectorAll('.geo');
			geoLoc.forEach(geoInfo => {
				geoInfo.classList.toggle('hide')
			});
		}
		hideGeoloc.addEventListener('click', toggleLongLat);
		
		// Sortable table
		/* 	Doing it this way to make the function more generalized and re-usable for future projects
		or if there are multiple tables on a page, but let's be honest, that's seldom the case
		*/
		// Find tables that are sortable
		const sortTable = document.querySelectorAll('table.sortable');
		
		
		// Then let's iterate through the tables and make sure they have a thead as the th will be the sortable data and action
		for (i = 0; i < sortTable.length; i++) {
			table = sortTable[i];
			if (thead = table.querySelector('thead')) {
				headers = thead.querySelectorAll('th.sortOpt');
				for (j = 0; j < headers.length; j++) {
					headers[j].innerHTML = `<button>` + headers[j].innerText + `</button>`;
				}
				thead.addEventListener('click', sortTableFunction(table));
			}
		}
		function sortTableFunction(table) {
			return function(e) {
				if (e.target.tagName.toLowerCase() == 'button') {
					sortRows(table, siblingIndex(e.target.parentNode));
					e.preventDefault();
				}
			};
		}
		function siblingIndex(node) {
			let count = 0;
			while (node = node.previousElementSibling) {
				count++;
			}
			return count;
		}
		
		function sortRows(table, columnIndex) {
			var rows = table.querySelectorAll('tbody tr'),
			sel = 'thead th:nth-child(' + (columnIndex + 1) + ')',
			sel2 = 'td:nth-child(' + (columnIndex + 1) + ')',
			classList = table.querySelector(sel).classList,
			values = [],
			cls = '',
			allNum = true,
			val,
			index,
			node;
			
			if (classList) {
				if (classList.contains('date')) {
					cls = "date";
				} else if (classList.contains('number')) {
					cls = "number";
				}
			}
			
			for (index = 0; index < rows.length; index++) {
				node = rows[index].querySelector(sel2);
				val = node.innerText;
				
				if (isNaN(val)) {
					allNum = false;
				} else {
					val = parseFloat(val);
				}
				
				values.push({ value: val, row: rows[index] });
			}
			
			if (cls == "" && allNum) {
				cls = "number";
			}
			
			if (cls == "number") {
				values.sort(sortNumberVal);
				values = values.reverse();
			} else if (cls == "date") {
				values.sort(sortDateVal);
			} else {
				values.sort(sortTextVal);
			}
			
			for (var idx = 0; idx < values.length; idx++) {
				table.querySelector("tbody").appendChild(values[idx].row);
			}
		}
		
		/**
		* Compare two 'value objects' numerically
		*/
		function sortNumberVal(a, b) {
			return sortNumber(a.value, b.value);
		}
		
		/**
		* Numeric sort comparison
		*/
		function sortNumber(a, b) {
			return a - b;
		}
		
		/**
		* Compare two 'value objects' as dates
		*/
		function sortDateVal(a, b) {
			var dateA = Date.parse(a.value),
			dateB = Date.parse(b.value);
			
			return sortNumber(dateA, dateB);
		}
		
		/**
		* Compare two 'value objects' as simple text; case-insensitive
		*/
		function sortTextVal(a, b) {
			var textA = (a.value + "").toUpperCase();
			var textB = (b.value + "").toUpperCase();
			
			if (textA < textB) {
				return -1;
			}
			
			if (textA > textB) {
				return 1;
			}
			
			return 0;
		}
		
		
		
		// This is for when I couldn't get the data to show on page load and needed a button event listener
		//const loader = document.querySelector('.loader'); // Because I don't know how the fuck to get the page to load with the data displayed
		//loader.addEventListener('click', buildTable);
		
	</script>
</body>
</html>
